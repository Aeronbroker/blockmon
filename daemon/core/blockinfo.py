from block import BlockInfo, GateInfo, VariableInfo, IntegerRange

block_infos = {"SynthSource": BlockInfo("SynthSource", "indirect", [GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element rate {\n         attribute pps {xsd:integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <rate pps='10000'/>\n      </params>\n    </paramsexample>\n", [], "Generates TCP/IP packets with random IP addresses and ports.    The number of packets per second can be tuned as a configuration parameter.", "Generates synthetic traffic with random addresses and ports", True), "FlowFilter": BlockInfo("FlowFilter", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n            element ip_src{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element ip_dst{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element l4_protocol{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element src_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element dst_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n            <ip_src address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='discard'/>\n            </ip_src>\n \n            <ip_dst address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='accept'/>\n             </ip_dst>\n \n             <l4_protocol number='6'>\n                <filter_mode behavior='accept'/>\n            </l4_protocol>\n \n            <src_port number='80'>\n                <filter_mode behavior='accept'/>\n            </src_port>\n \n      </params>\n    </paramsexample>\n", [], "", "Selects packets based on conditions specified over the 5-tuple", False), "SynFloodDetector": BlockInfo("SynFloodDetector", "direct", [GateInfo("input", "in_sketch", "SketchMsg", IntegerRange(0, 0)), GateInfo("output", "out_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element cusum {\n         attribute threshold {integer}\n         attribute offset {integer}\n         attribute mean_window {integer}\n       }\n       element bpf_filter {text}?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <cusum threshold='50' offset='10' mean_window='20' />\n      </params>\n    </paramsexample>\n", [], "Detects TCP SYN Flooding from counters in sketches.  	   Sketches are received regularly with the number of TCP SYN packets  	   seen by destination IP since the last sketch was sent.      The CUSUM algorithm is used to detect abrupt changes in the numbers of      the sketch. Its parameters can be configured:  	    threshold is the indicator value over which an alarm will be raised       offset is the variation in counts considered normal       mean_window is the number of sketches on which the mean is computed      When a SYN flooding is detected, it is logged and a message is sent      through out_alert with the indexes of the cells in alarm. 	   This message may be used to identify the target of the attack.", "Detects TCP SYN Flooding from counters in sketches", False), "SketchFlowCounter": BlockInfo("SketchFlowCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n    </paramsexample>\n", [], "Counts the number of packets per flow using a sketch, where a flow is      identified using the 5-tuple. Only TCP and UDP packets are considered.", "Counts the number of packets per flow using a sketch", False), "TopNFlowSelector": BlockInfo("TopNFlowSelector", "both", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_flow", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element top_flows{\n        attribute number {xsd:integer}\n        }?\n        element period{\n        attribute msecs {xsd:integer}\n        }?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n             <top_flows number='10'/>\n             <period msecs='4000'/>\n      </params>\n    </paramsexample>\n", [], "Receives Flow messages and keeps a list of the N messages with the highest number of packets         Upon expiration of a timer, it sends all of them out of its out gate.         The number N of messages to be selected, along with the flush period, are optional configuration parameters.         Default values are 10 messages and 100ms respectively", "Selects the flows with the highest number of packets", False), "SyncTag": BlockInfo("SyncTag", "both", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element tags\n        {\n            element tag {\n            attribute name {text}\n            }\n         }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <tag name = 'tag1'/>\n        <tag name = 'tag2'/>\n        </tags>\n        </params>\n    </paramsexample>\n", [], "Test block that waits for a message to have a set of tags set before forwarding it.    The block is configured with a set of tag to wait for: if all of them are written (the value is not read)    it forwards the message to the next block, otherwise it discards it.    If the same message is going through different parallel processing chains, is will reach the synchronization    block several times and eventually all of its tags will be written.", "Wait for a message to have a set of tags written", False), "SynFloodAlertManager": BlockInfo("SynFloodAlertManager", "direct", [GateInfo("input", "in_alert", "Alert", IntegerRange(0, 0)), GateInfo("output", "out_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n  		element history {\n 		  attribute size {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Receives different alerts from TCPFlagCounter blocks and merges them into more 	   informative alerts, ready for mitigation.      Keeps an history of the alerts with a configurable maximum size.", "Receives SYN flooding alerts and summarizes them.", False), "PcapSource": BlockInfo("PcapSource", "async", [GateInfo("output", "source_out", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element source {\n         attribute type {'live' | 'trace'}\n         attribute name {text}\n       }\n       element bpf_filter {text}?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <source type='live' name='eth0'>\n         or\n         <source type='trace' name='trace.pcap'>\n \n       <bpf_filter expression=' '>\n      </params>\n    </paramsexample>\n", [], "Captures traffic from a local interface or pcap trace file and outputs      packets using a Packet message. If the source parameter is set to live,      the name parameter should be an interface's name (e.g., eth0). If the      source type is set to trace, then the name should be the full path to a      pcap trace file (e.g., /tmp/mytrace.pcap). Use the bfp paramter to filter      traffic using BFP syntax.", "Captures traffic from a local interface or pcap trace file", True), "ComboPktSource": BlockInfo("ComboPktSource", "indirect", [GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element design {\n           attribute filename {xsd:string}\n       }\n       element channels {\n           attribute rx_mask {xsd:integer}\n       }\n       element interfaces {\n           attribute enable {xsd:integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params> \n       <design filename='/path/to/firmware.mcs'/>\n       <channels rx_mask='255'/>\n       <interfaces enable='1'/>\n   </params>\n    </paramsexample>\n", [VariableInfo("ComboPktSource", "pktcnt", "integer", "read"), VariableInfo("ComboPktSource", "pktagg", "integer", "write")], "This block is a wrapper to the SZE2 API available as a part of NetCOPE FPGA framework:     http://www.invea-tech.com/products-and-services/netcope-fpga-platform     A block of this kind can be associated to one or more hardware queues    available on the FPGA acceleration card. Subscribed queues are specified    as a configuration parameter in a mask where each bit corresponds to a single queue.    If no value is provided default value is used. This block supports batch    message allocation in order to optimize performance", "Captures traffic from a local interface by means of the SZE2 API as part of NetCOPE", True), "IDMEFExporter": BlockInfo("IDMEFExporter", "direct", [GateInfo("input", "in_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element export {\n            attribute host  {text},\n            attribute port {xsd:integer}\n            } |\n        element file {\n            attribute name {text}\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <export host='192.168.0.3' port='1234' />\n      </params>\n    </paramsexample>\n", [], "Receives alert messages and exports them as IDMEF.      Export can ben done to a file or to a distant machine through TCP.", "Receives alert messages and exports them as IDMEF", False), "TCPFlagCounter": BlockInfo("TCPFlagCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("input", "in_alert", "Alert", IntegerRange(0, 0)), GateInfo("output", "out_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element export {\n         attribute period {integer}\n       }\n       element sketch {\n         attribute width {integer}\n         attribute depth {integer}\n         element hash {\n           attribute a {integer}\n           attribute b {integer}\n         }\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n       <params>\n       <export period='500000' />\n       <sketch width='1024' depth='2'>\n         <hash a='12' b='4587' />\n         <hash a='458' b='56332' />\n       </sketch>\n      </params>\n    </paramsexample>\n", [], "Counts the TCP SYN packets sent to each IP. Stores the counts  	   in a CMS sketch and sends the sketch regularly.  	   In a future version, the TCP flags counted will be configureable.   	   Packets are received through the gate in_pkt.  	   The CMS sketch can be configured:  	    width is the number of values each hash function can take  	    depth is the number of hash functions       hash functions may be defined by their parameters a and b. If there        are not at least 'depth' functions defined, they will be chosen 		 randomly.  	   The export rate can be configured:  	    period is the number of microseconds between each sketch is sent.  	   Alerts can also be received through gate in_alert. These      alerts contain the indexes of counts in alarm. This blocks associates      them with a destination IP that it logs when an alert is received.      The destination IP is determined using a list of recently-seen IPs and sent      as an enriched alert.", "Counts TCP SYN packets by target IP in sketches", False), "RRDemux": BlockInfo("RRDemux", "direct", [GateInfo("input", "input", "Msg", IntegerRange(0, 0)), GateInfo("output", "output1", "Msg", IntegerRange(0, 0)), GateInfo("output", "output2", "Msg", IntegerRange(0, 0)), GateInfo("output", "outputN", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element gates {\n         attribute number {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <gates number='5' />\n      </params>\n    </paramsexample>\n", [], "Receives messages and sends them through a configured number      of output gates in a round-robin fashion. There can be any number of      output gates, each named outputX with X going from 1 to the configured      number of gates.", "Sends messages out through its gates in a round-robin fashion", False), "PeriodFlowMeter": BlockInfo("PeriodFlowMeter", "indirect", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element timeout{\n            attribute ms {xsd:integer}\n            }?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n           <timeout ms='500'/>\n      </params>\n    </paramsexample>\n", [], "Receives packet messages and keeps a table of per-flow statistics.        Upon expiration of a timer (default is 500 ms), the whole table is flushed: a Flow message for        every table entry is sent out and the whole state of the table is erased.", "Receives packet messages and keeps a table of per-flow    statistics, exporting them periodically", False), "ComboUHSource": BlockInfo("ComboUHSource", "indirect", [GateInfo("output", "out_pkt", "UHPacket", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element design {\n           attribute filename {xsd:string}\n       }\n       element channels {\n           attribute rx_mask {xsd:integer}\n       }\n       element interfaces {\n           attribute enable {xsd:integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params> \n       <design filename='/path/to/firmware.mcs'/>\n       <channels rx_mask='255'/>\n       <interfaces enable='1'/>\n   </params>\n    </paramsexample>\n", [VariableInfo("ComboUHSource", "pktcnt", "integer", "read"), VariableInfo("ComboUHSource", "pktagg", "integer", "write")], "This block is a wrapper to the SZE2 API available as a part of NetCOPE FPGA framework:     http://www.invea-tech.com/products-and-services/netcope-fpga-platform     A block of this kind can be associated to one or more hardware queues    available on the FPGA acceleration card. Subscribed queues are specified    as a configuration parameter in a mask where each bit corresponds to a single queue.    If no value is provided default value is used. This block supports batch    message allocation in order to optimize performance", "Captures traffic from a local interface by means of the SZE2 API as part of NetCOPE", True), "PacketCounter": BlockInfo("PacketCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "     <paramsexample>\n         <params>\n               <notimer/>\n           </params>\n        \n    </paramsexample>\n", [VariableInfo("PacketCounter", "pktcnt", "integer", "read"), VariableInfo("PacketCounter", "bytecnt", "integer", "read"), VariableInfo("PacketCounter", "byterate", "integer", "read"), VariableInfo("PacketCounter", "pktrate", "integer", "read"), VariableInfo("PacketCounter", "reset", "write 1 to reset packet and byte counts", "write")], "Keeps packet and byte counts of traffic going through it and logs,      every 0.5 seconds, the packet rate.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps packet and byte counts of traffic going through it.", False), "PacketPrinter": BlockInfo("PacketPrinter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Receives a Packet message and prints its associated information    (as returned by the methods in the Packet class)", "Prints meta-information regarding a packet", False), "PacketCounter": BlockInfo("PacketCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "     <paramsexample>\n         <params>\n               <notimer/>\n           </params>\n        \n    </paramsexample>\n", [VariableInfo("PacketCounter", "pktcnt", "integer", "read"), VariableInfo("PacketCounter", "bytecnt", "integer", "read"), VariableInfo("PacketCounter", "byterate", "integer", "read"), VariableInfo("PacketCounter", "pktrate", "integer", "read"), VariableInfo("PacketCounter", "reset", "write 1 to reset packet and byte counts", "write")], "Keeps packet and byte counts of traffic going through it and logs,      every 0.5 seconds, the packet rate.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps packet and byte counts of traffic going through it.", False), "PFQSource": BlockInfo("PFQSource", "indirect", [GateInfo("output", "source_out", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element queues {\n           attribute device {text}\n           element queue {\n                attribute number {xsd:integer}\n                }\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params>                                                                                                                                 \n       <queues device='eth3'>\n           <queue number='0'/>\n       </queues> \n   </params>\n    </paramsexample>\n", [], "Wrapper to the PFQ capturing engine:     http://netgroup.iet.unipi.it/software/pfq/     A block of this kind can be associated to a network interface or to a    subset of its associated hardware queues. This is specified as a    configuration parameter: a set of queues for the interface can be    specified, if this is empty the block captures all of the packets on the interface.    This block supports batch message allocation in order to optimize performance", "Captures traffic from a local interface by means of the PFQ capturing engine", True), "FlowMeter": BlockInfo("FlowMeter", "indirect", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       attribute store_packets {xsd:boolean}?\n       element idle_timeout{\n            attribute ms {xsd:integer}\n            }?\n       element idle_timeout{\n            attribute ms {xsd:integer}\n            }?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params store_packets='true'>\n           <active_timeout ms='500'/>\n           <idle_timeout ms='100'/>\n      </params>\n    </paramsexample>\n", [], "Receives packet messages and keeps a table of per-flow statistics, and, depending on the configuration, also the packets making up that flow.        A circular queue is used to keep track of the last time a flow has been checked for         expiration.         Two timeout values are used. The first one is the idle timeout (default value is 500 ms): whenever a flow record has not been        receiving a packet for more than such time interval, the flow is considered as expired, its associated        record is sent out and its table entry erased .      The second one, the active timeout (default value is 100 ms), is activated when a flow has been active for longer than the corresponding time        interval. When such timeout expires, a record about the flow is sent out and the counters in the corresponding table entry        are reset.         Notice that, while the idle timeout is checked by using a Blockmon timer mechanism, the indirect timeout is checked upon        arrival of a new packet belonging to the flow.", "Receives packet messages and keeps a table of per-flow statistics, and, depending on the configuration, also the packets making up that flow.", False), "L4Demux": BlockInfo("L4Demux", "direct", [GateInfo("input", "in_pkt", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_tcp", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_udp", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_unknown", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n    </paramsexample>\n", [], "Takes Packet messages and demultiplexes them across three possible output    gates depending on their transport protocol: TCP packets are forwarded    through the out_tcp gate, UDP packets through out_udp and any other packet    through out_unknown.", "Demultiplexes packets based on their transport protocol", False), "FlowCounter": BlockInfo("FlowCounter", "direct", [GateInfo("input", "in_pkt", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "     <paramsexample>\n         <params>\n               <notimer/>\n           </params>\n        \n    </paramsexample>\n", [VariableInfo("FlowCounter", "pktcnt", "integer", "read"), VariableInfo("FlowCounter", "bytecnt", "integer", "read"), VariableInfo("FlowCounter", "flowcnt", "integer", "read"), VariableInfo("FlowCounter", "byterate", "integer", "read"), VariableInfo("FlowCounter", "pktrate", "integer", "read"), VariableInfo("FlowCounter", "flowrate", "integer", "read"), VariableInfo("FlowCounter", "reset", "write 1 to reset counts", "write")], "Keeps flow, packet and byte counts of Flows going through it.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps flow packet and byte counts of traffic going through it.", False), "AppendTag": BlockInfo("AppendTag", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element tag\n        {\n            attribute type {'long'|'double'|'int'}\n            attribute id {text}\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <tag type='double' name = 'random_tag'/>\n      </params>\n    </paramsexample>\n", [], "This is a test-only block that appends random-value tags to Packet messages.        The block can append three different tag type, which can be configured at block configuration time.        The content of the tag to be written is a 64-bit random value which is computed on a per-packet base.", "Appends tags with random values to the packet message.", False), "IPFIXSource": BlockInfo("IPFIXSource", "async", [GateInfo("output", "source_out", "Any", IntegerRange(0, 0))], "   <paramsschema>\n     element params {\n        element collect {\n            attribute transport {'udp'|'tcp'|'sctp'},\n            attribute port      {xsd:integer}?\n            } |\n        element file {\n            attribute name {text}\n        }\n        element datatype {\n            attribute name {text}\n        }\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <collect port='4739' transport='tcp'/>\n        <datatype name='ipv4flow'/>\n        or\n        <file name='foo.ipfix'/>\n        <datatype name='ipv4flow'/>\n      </params>\n    </paramsexample>\n", [], "Reads records from an IPFIX transport session and outputs messages       according to the datatypes registered with the source block. May      send out Messages of any type, depending on the data received from       the remote IPFIX device and the the registered data types.", "Receives messages from an IPFIX exporter", True), "SketchMerger": BlockInfo("SketchMerger", "direct", [GateInfo("input", "in_sketch", "SketchMsg", IntegerRange(0, 0)), GateInfo("output", "out_sketch", "SketchMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element merge {\n         attribute number {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <merge number='3' />\n      </params>\n    </paramsexample>\n", [], "Receives CMS sketches and merges them to send only one.  	   All sketches received should have the same width and depth, and use the      same hash functions. When the configured number of sketches have been received,  	   they are merged together and sent, and the cycle restarts.", "Receives CMS sketches and merges them.", False), "Null": BlockInfo("Null", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Discards every message it receives.", "Discards every message it receives.", False), "ProtocolFilter": BlockInfo("ProtocolFilter", "direct", [GateInfo("input", "in_pkt", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n           element protocol{\n            attribute type {xsd:integer}\n            }?\n           }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n            <!-- select IP packets -->\n            <protocol type='0800' />\n      </params>\n    </paramsexample>\n", [], "", "Selects packets based on the value of the ethernet type field", False), "CDFGenerator": BlockInfo("CDFGenerator", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element cdf_build {\n                attribute interval {xsd:integer}\n            }\n       element cdf_param{\n            attribute min {xsd:integer}\n            attribute max {xsd:integer}\n            attribute bin {xsd:integer}\n            }\n       element diff_priv{\n            attribute epsilon {xsd:float}\n            }\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n             <build_cdf interval='2000'/> #millisecond\n             <cdf_param min='0' max='1500' bin='150'/>\n             <diff_priv epsilon='0.8'/> #if -1 do not add noise\n        </params>\n    </paramsexample>\n", [], "Implements a block that prints the Cumulative Distribution Function        (CDF) of the packet size every interval, adding a noise depending on        the epsilon value. Configuration parameters allow to tune the        endpoints of the CDF, the bin width and to add noise.", "Prints the CDF of packet sizes for a given interval", False), "PacketFilter": BlockInfo("PacketFilter", "direct", [GateInfo("input", "in_pkt", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n           element l3_protocol{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element ip_src{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element ip_dst{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element l4_protocol{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element src_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element dst_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n            <l3_protocol number='2048'>\n                <filter_mode behavior='accept'/>\n            </l3_protocol>\n \n            <ip_src address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='discard'/>\n            </ip_src>\n \n            <ip_dst address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='accept'/>\n             </ip_dst>\n \n             <l4_protocol number='6'>\n                <filter_mode behavior='accept'/>\n            </l4_protocol>\n \n            <src_port number='80'>\n                <filter_mode behavior='accept'/>\n            </src_port>\n \n      </params>\n    </paramsexample>\n", [], "", "Selects packets based on conditions specified over the 5-tuple", False), "IPDumbAnonymizer": BlockInfo("IPDumbAnonymizer", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element anon {\n         attribute src {'True' | 'False'}?\n         attribute dst {'True' | 'False'}?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <anon src='True'/>\n      </params>\n    </paramsexample>\n", [], "This block can anonymize the source address and/or the destination    address of an IP packet (this can be set as config param). Notice that, as    this operation needs to modify the packet contents, the message is cloned    before being modified.", "Anonymizes ip addresses in a Packet message", False), "Null": BlockInfo("Null", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Discards every message it receives.", "Discards every message it receives.", False), "FlowPrinter": BlockInfo("FlowPrinter", "direct", [GateInfo("input", "in_flow", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Receives a Flow message and prints its associated information (as returned    by the methods in the Flow class)", "Prints meta-information regarding a flow", False), "IPFIXExporter": BlockInfo("IPFIXExporter", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element domain {xsd:integer}?,\n        element export {\n            attribute transport {'udp'|'tcp'|'sctp'},\n            attribute host  {text},\n            attribute port  {xsd:integer}?\n            } |\n        element file {\n            attribute name {text}\n        }\n        element datatype {\n            attribute name {text}\n        }\n        element fastflush?\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <domain id='1'/>\n        <export host='ipfix-collector.example.net' port='4739' transport='tcp'/>\n        <datatype name='ipv4flow'/>\n        or\n        <file name='foo.ipfix'/>\n        <datatype name='ipv4flow'/>\n      </params>\n    </paramsexample>\n", [], "Receives a message and exports it via an IPFIX transport session or into   an IPFIX file. This block can handle any message class for which there   is a registered record type.    Note that this block can handle any message class for which an associated   datatype entry exists in the configuration. Messages sent to this block    for which no datatype entry is available are ignored but logged.", "Exports Blockmon messages via IPFIX", True), "BooleanCombiner": BlockInfo("BooleanCombiner", "indirect", [GateInfo("input", "in_boolcombiner", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_boolcombiner", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element source {\n         attribute fields {'text in CSV format'}\n       }\n       element result_key {\n         attribute name {'text'}\n       }\n       element operation {\n         attribute name {'and' | 'or' | 'not'}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n 	  <source fields='src,dst'>\n         <operation type='and'>\n         <result_key name='new_callee'>\n      </params>\n    </paramsexample>\n", [], "Combines boolean values and returns the result of the logic operation.      The block takes as input the keys (in CSV format) to combine,       together with the logic operation to perform and the key where to write the result of the logical operation.      The block returns the result of the logical operation, by adding a field to the input PairMsg.", "Combines boolean values and returns the result of the logic operation.", True), "Selector": BlockInfo("Selector", "indirect", [GateInfo("input", "in_selector", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_selector", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Upon arrival of an incoming message, it discards messages with the 'select' tag 	sets to zero.", "Forwards the incoming message towards one or more output gates.", True), "FoFiRCalculator": BlockInfo("FoFiRCalculator", "indirect", [GateInfo("input", "in_fofir", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_fofir", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element result_key {\n         attribute name {'text'}\n       }\n       element basewindow {\n         attribute value {text containing an integer}\n       }\n       element activation {\n         attribute value {text containing an integer}\n       }\n       element threshold {\n         attribute upperbound {text containing a double}\n         attribute lowerbound {text containing a double}\n       }\n       element threshold_zero {\n         attribute upperbound {text containing a double}\n         attribute lowerbound {text containing a double}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <result_key name='fofir'>\n         <basewindow value='base-window length (seconds), e.g., 360'>\n         <activation value='min numbers of calls to activate the metric, e.g., 30'>\n         <threshold lowerbound='threshold value - lower bound, e.g., 2' upperbound='threshold value - upper bound, e.g., 10'>\n         <threshold_zero lowerbound='threshold value to deal with denominator is zero - lower bound, e.g., 2' upperbound='threshold value to deal with denominator is zero - upper bound, e.g., 10'>\n      </params>\n    </paramsexample>\n", [], "Computes the FoFiR metric.      The block takes as input the PairMsg + tags with the CDR fields.      The block returns the result of the FoFiR metric, by adding a field to the input PairMsg.", "Computes the FoFiR metric.", True), "TBloomFilter": BlockInfo("TBloomFilter", "indirect", [GateInfo("input", "in_tbf", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_tbf", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element id_key {\n         attribute name {text}\n       }\n       element count_key {\n         attribute name {text}\n       }\n       element result_key {\n         attribute name {text}\n       }\n       element add_key {\n         attribute name {text}\n       }\n       element timewindow {\n         attribute value {text containing an integer}\n       }\n       element basewindow {\n         attribute value {text containing an integer}\n       }\n       element hashsize {\n         attribute value {text containing an integer}\n       }\n       element filtersize {\n         attribute value {text containing an integer}\n       }\n       element addvalue{\n         attribute type {'static' | 'dynamic'}\n         attribute value {text: if type is static this field contains an integer, otherwise it contains the name of the key from which to get the value}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <id_key name='field to look up for the operation add'>\n         <count_key name='field to look up for the operation count'>\n         <result_key name='field where to write the result'>\n         <add_key name='perform add operation if this field is true'>\n         <timewindow value='time-window length (seconds)'>\n         <basewindow value='base-window length (seconds), e.g., 360'>\n  	  <hashsize value='8'/>\n         <filtersize value='20'/>\n         <addvalue type='static' value='1'>\n      </params>\n    </paramsexample>\n", [], "Implements a time-decaying counting bloom filter.      Two operations are allowed: add(key,valueToadd) and check(key).       Input: PairMsg message, plus additional tags from the TagRegister classs      Output: PairMsg message, plus additional tags from the TagRegister classs", "Implements a time-decaying counting bloom filter.", True), "BlackHole": BlockInfo("BlackHole", "indirect", [GateInfo("input", "in_blackhole", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element output {\n 	 attribute name {'text'}\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n 	  <output name='output.log'>\n      </params>\n    </paramsexample>\n", [], "Prints the received message.", "Prints the received message.", True), "BFMembershipChecker": BlockInfo("BFMembershipChecker", "indirect", [GateInfo("input", "in_bfmcheck", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_bfmcheck", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element source_key {\n         attribute name {text}\n       }\n       element result_key {\n         attribute name {text}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <source_key name='field to look up'>\n         <result_key name='field where to write the result'>\n      </params>\n    </paramsexample>\n", [], "Adds an element to a set and returns whether that element was already part of the set before.      The operation is implemented in an approximate 'time-windowed' manner, i.e., elements are removed from the set after a while.      Returns as output the same list as input plus an additional field       specifying if the element belongs to the set.", "Adds an element to a set and returns whether that element was already part of the set before.", True), "Dispatcher": BlockInfo("Dispatcher", "indirect", [GateInfo("input", "in_disp", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_disp", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element gates {\n         attribute number {'text'}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n 	  		<gates number='3'>\n      </params>\n    </paramsexample>\n", [], "Upon arrival of an incoming message, it forwards it to all its 		output gates. Note that the block does not make any copy of the  		message. The number of output gates is  		taken as input parameter and the gates will be named by appending 		an increasing number to it. For instance, with number=2, the  		function creates the following output gates: out_disp0, out_disp1.", "Forwards the incoming message towards all output gates.", True), "ScoreCombiner": BlockInfo("ScoreCombiner", "indirect", [GateInfo("input", "in_score", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_score", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element result_key {\n         attribute name {'text'}\n       }\n       element source {\n         attribute fields {'text' in CSV format}\n       }\n       element weights {\n         attribute values {'text' in CSV format}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <result_key name='score'>\n         <source fields='fofir,url,acd'>\n         <weights values='2,3,3'>\n      </params>\n    </paramsexample>\n", [], "Computes the weighted sum of a list of values.      The block takes as input the PairMsg + tags with the CDR fields.      The block returns the result of the weighted sum, by adding a field to the input PairMsg.      The element source must include an attribute fields including a string with a list of fields to consider for the weighted sum (CSV)      The element weights must include an attribute values including a string with a list of integer (CSV)", "Computes the weighted sum.", True), "ACDCalculator": BlockInfo("ACDCalculator", "indirect", [GateInfo("input", "in_acd", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_acd", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element result_key {\n         attribute name {'text'}\n       }\n       element timewindow {\n         attribute value {text containing an integer}\n       }\n       element basewindow {\n         attribute value {text containing an integer}\n       }\n       element activation {\n         attribute value {text containing an integer}\n       }\n       element threshold {\n         attribute upperbound {text containing a double}\n         attribute lowerbound {text containing a double}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <result_key name='acd'>\n         <timewindow value='time-window length (seconds)'>\n         <basewindow value='base-window length (seconds), e.g., 360'>\n         <activation value='min numbers of calls to activate the metric, e.g., 30'>\n         <threshold lowerbound='threshold value - lower bound, e.g., 0.1' upperbound='threshold value - upper bound, e.g., 0.2'>\n      </params>\n    </paramsexample>\n", [], "Computes the ACD metric.      The block takes as input the PairMsg + tags with the CDR fields.      The block returns the result of the ACD metric, by adding a field to the input PairMsg.", "Computes the ACD metric.", True), "MsgCloner": BlockInfo("MsgCloner", "indirect", [GateInfo("input", "in_cloner", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_cloner", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element gates {\n         attribute number {'text'}\n       }\n       element map_keys {\n         attribute fields {'text in CSV format'}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n 	<gates number='3'/>\n      	<map_keys fields='src,dst'/>\n      </params>\n    </paramsexample>\n", [], "Upon arrival of an incoming message, it clones it to one or more  	output gates. The hash of each map_key provided as input parameter  	will return the output gate number, towards which the block  	forwards the incoming message to. The number of output gates is  	taken as input parameter and the gates will be named by appending 	an increasing number to it. For instance, with number=2, the  	function creates the following output gates: out_disp0, out_disp1.", "Clones the incoming message towards one or more output gates.", True), "CDRSource": BlockInfo("CDRSource", "indirect", [GateInfo("output", "source_out", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element source {\n         attribute type {'offline'}\n         attribute name {text}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <source type='offline' name='filename.cdr'>\n      </params>\n    </paramsexample>\n", [], "Reads CDRs (sorted by timestamp in ascending order) from file and       outputs the fields for each        recorded CDR by using a PairMsg message and appending tags of the class TagRegister      If the source type is set to cdrfile, then the name should be the       full path to a file containing the CDRs (e.g., /tmp/calls.cdr).", "Reads CDRs (sorted by timestamp) from a file and parses them.", True), "ThresholdComparator": BlockInfo("ThresholdComparator", "indirect", [GateInfo("input", "in_thcomparator", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_thcomparator", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element result_key {\n         attribute name {'text'}\n       }\n       element field {\n         attribute name {'text'}\n       }\n       element threshold {\n         attribute value {'text'}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <result_key name='telemarketer'>\n         <field name='score'>\n         <threshold value='0.75'>\n      </params>\n    </paramsexample>\n", [], "Compares the value of a field against a given threshold.      The block takes as input the PairMsg + tags with the CDR fields.      The block returns true if the value is equal or above the threshold, by adding a field to the input PairMsg.      The element threshold must include an attribute value that specifies the threshold value.      The element field must include an attribute name that specifies the key to compare against the threshold value.", "Compares the value of a field against a given threshold.", True), "CDRSource2": BlockInfo("CDRSource2", "indirect", [GateInfo("output", "source_out", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element source {\n         attribute type {'offline'}\n         attribute name {text}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <source type='offline' name='filename.cdr'>\n      </params>\n    </paramsexample>\n", [], "Reads CDRs (sorted by timestamp in ascending order) from file and       outputs the fields for each        recorded CDR by using a PairMsg message and appending tags of the class TagRegister      If the source type is set to cdrfile, then the name should be the       full path to a file containing the CDRs (e.g., /tmp/calls.cdr).", "Reads CDRs (sorted by timestamp) from a file and parses them.", True), "Resetter": BlockInfo("Resetter", "direct", None, "    <paramsschema>\n     element params {\n       element reset {\n         attribute name {'composition'}\n         attribute name {'blocks'}\n       }\n       element check{\n         attribute name {'interval'}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <reset composition='thisCompostitionsName' blocks='block1,block2,block3'/>\n         <check interval='500'/>\n      </params>\n    </paramsexample>\n", [VariableInfo("Resetter", "reset", "integer", "write")], "When 'reset' variable is set to one, the reset() method of all blocks listed in the parameters is called.      Those block must inherit from blockmon::Resettable", "Resets several blocks", True), "Collector": BlockInfo("Collector", "indirect", [GateInfo("input", "in_coll", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_coll", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element gates {\n         attribute number {'text'}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n 	  		<gates number='3'>\n      </params>\n    </paramsexample>\n", [], "Upon arrival of an incoming message, it forwards it to all its 		output gates. Note that the block does not make any copy of the  		message. The number of output gates is  		taken as input parameter and the gates will be named by appending 		an increasing number to it. For instance, with number=2, the  		function creates the following output gates: out_disp0, out_disp1.", "Forwards the incoming message towards all output gates.", True), "UserStatsCalculator": BlockInfo("UserStatsCalculator", "indirect", [GateInfo("input", "in", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Holds and updates per-user statistics and calls.", "Holds and updates per-user statistics and calls.", True), "URLCalculator": BlockInfo("URLCalculator", "indirect", [GateInfo("input", "in_url", "PairMsg", IntegerRange(0, 0)), GateInfo("output", "out_url", "PairMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element result_key {\n         attribute name {'text'}\n       }\n       element basewindow {\n         attribute value {text containing an integer}\n       }\n       element activation {\n         attribute value {text containing an integer}\n       }\n       element threshold {\n         attribute upperbound {text containing a double}\n         attribute lowerbound {text containing a double}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <result_key name='url'>\n         <basewindow value='base-window length (seconds), e.g., 360'>\n         <activation value='min numbers of calls to activate the metric, e.g., 30'>\n         <threshold lowerbound='threshold value - lower bound, e.g., 0.5' upperbound='threshold value - upper bound, e.g., 1'>\n      </params>\n    </paramsexample>\n", [], "Computes the URL metric.      The block takes as input the PairMsg + tags with the CDR fields.      The block returns the result of the URL metric, by adding a field to the input PairMsg.", "Computes the URL metric.", True)}
